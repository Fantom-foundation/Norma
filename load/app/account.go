// Copyright 2024 Fantom Foundation
// This file is part of Norma System Testing Infrastructure for Sonic.
//
// Norma is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Norma is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with Norma. If not, see <http://www.gnu.org/licenses/>.

package app

import (
	"context"
	"crypto/ecdsa"
	"encoding/binary"
	"fmt"
	"math/big"
	"sync/atomic"

	"github.com/Fantom-foundation/Norma/driver/rpc"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
)

// AccountFactory use one mnemonic phrase to generate any amount accounts, by BIP-39 standard.
// Any factory using the same mnemonic, feederId and appId produce the same sequence of accounts,
// which can be used to reuse existing accounts from previous runs.
type AccountFactory struct {
	chainID         *big.Int
	numAccounts     int64
	feederId, appId uint32
}

// NewAccountFactory creates a new AccountFactory, generating accounts for given feeder and app.
// Re-creating a factory using the same feederId and appId will produce the same sequence of accounts.
func NewAccountFactory(chainID *big.Int, feederId, appId uint32) (*AccountFactory, error) {
	return &AccountFactory{
		chainID:     chainID,
		numAccounts: 0,
		feederId:    feederId,
		appId:       appId,
	}, nil
}

// CreateAccount generates the next account in the sequence generated by the AccountFactory.
func (f *AccountFactory) CreateAccount(rpcClient rpc.RpcClient) (*Account, error) {
	id := atomic.AddInt64(&f.numAccounts, 1)
	d := make([]byte, 32)
	binary.BigEndian.PutUint64(d[:24], uint64(id))
	binary.BigEndian.PutUint32(d[24:], f.feederId)
	binary.BigEndian.PutUint32(d[28:], f.appId)
	privateKey, err := crypto.ToECDSA(d)
	if err != nil {
		return nil, err
	}
	address := crypto.PubkeyToAddress(privateKey.PublicKey)

	nonce, err := rpcClient.NonceAt(context.Background(), address, nil) // nonce at latest block
	if err != nil {
		return nil, fmt.Errorf("failed to get address nonce; %v", err)
	}

	return &Account{
		privateKey: privateKey,
		address:    address,
		chainID:    f.chainID,
		nonce:      nonce,
	}, nil
}

// Account represents an account from which we can send transactions.
// It sustains the nonce value - it allows multiple generators which use one Account
// to produce multiple txs in one block.
type Account struct {
	id         int
	privateKey *ecdsa.PrivateKey
	address    common.Address
	chainID    *big.Int
	nonce      uint64
	publicKey  []byte
}

// NewAccount creates an Account instance from the provided private key
func NewAccount(id int, privateKeyHex string, publicKey []byte, chainID int64) (*Account, error) {
	privateKey, err := crypto.HexToECDSA(privateKeyHex)
	if err != nil {
		return nil, err
	}
	address := crypto.PubkeyToAddress(privateKey.PublicKey)
	return &Account{
		id:         id,
		privateKey: privateKey,
		address:    address,
		chainID:    big.NewInt(chainID),
		nonce:      0,
		publicKey:  publicKey,
	}, nil
}

// getNextNonce provides a nonce to be used for next transactions sent using this account
func (a *Account) getNextNonce() uint64 {
	current := atomic.AddUint64(&a.nonce, 1)
	return current - 1
}
